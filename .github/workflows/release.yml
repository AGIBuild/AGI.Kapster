name: Release Build & Publish

# å‘å¸ƒåˆ†æ”¯å’Œæ ‡ç­¾çš„æ­£å¼å‘å¸ƒæ„å»º
on:
  push:
    tags: [ 'v*' ]  # åªåœ¨ç‰ˆæœ¬æ ‡ç­¾æ¨é€æ—¶è§¦å‘
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.0.0)'
        required: true
      prerelease:
        description: 'Is this a pre-release?'
        type: boolean
        default: false

permissions:
  contents: write
  id-token: write
concurrency:
  group: release-${{ github.ref || github.event.inputs.tag }}
  cancel-in-progress: false

env:
  DOTNET_VERSION: '9.0.x'
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  # Optional code signing / notarization placeholders (override via repository/environment secrets if desired)
  CODE_SIGN_WINDOWS_PFX_BASE64: ''
  CODE_SIGN_WINDOWS_PFX_PASSWORD: ''
  MACOS_SIGN_IDENTITY: ''
  MACOS_NOTARIZE_APPLE_ID: ''
  MACOS_NOTARIZE_PASSWORD: ''
  MACOS_NOTARIZE_TEAM_ID: ''

jobs:
  prepare-release:
    name: ğŸ“‹ Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      version-number: ${{ steps.version.outputs.version-number }}
      is-prerelease: ${{ steps.version.outputs.is-prerelease }}
      
    steps:
    - name: ï¿½ Setup Complete Environment
      uses: ./.github/actions/setup-environment
      with:
        fetch-depth: 0
        dotnet-version: ${{ env.DOTNET_VERSION }}
        enable-nuget-cache: true
        
    - name: ğŸ“Š Determine version
      id: version
      shell: pwsh
      run: |
        Write-Host "Event Name: ${{ github.event_name }}"
        Write-Host "Ref Type: ${{ github.ref_type }}"
        Write-Host "Ref Name: ${{ github.ref_name }}"
        
        if ("${{ github.event_name }}" -eq "workflow_dispatch") {
          $version = "${{ github.event.inputs.tag }}"
          $isPrerelease = "${{ github.event.inputs.prerelease }}"
          Write-Host "Using workflow_dispatch inputs: $version"
        } elseif ("${{ github.ref_type }}" -eq "tag") {
          $version = "${{ github.ref_name }}"
          $isPrerelease = if ($version -match "-(alpha|beta|rc|preview)") { "true" } else { "false" }
          Write-Host "Using tag version: $version"
        } else {
          Write-Host "ERROR: Unexpected trigger condition" >&2
          exit 1
        }
        
        # Ensure version format
        if ($version -and -not $version.StartsWith("v")) {
          $version = "v$version"
        }
        
        # Export version without 'v' prefix for build scripts
        $versionNumber = $version -replace "^v", ""
        
        echo "version=$version" >> $env:GITHUB_OUTPUT
        echo "version-number=$versionNumber" >> $env:GITHUB_OUTPUT
        echo "is-prerelease=$isPrerelease" >> $env:GITHUB_OUTPUT
        
        Write-Host "ğŸ·ï¸ Release Version: $version"
        Write-Host "ğŸ”¢ Version Number: $versionNumber"
        Write-Host "ğŸ”„ Is Prerelease: $isPrerelease"

    - name: ğŸ” Enforce tag originates from release branch
      if: ${{ github.ref_type == 'tag' }}
      shell: pwsh
      run: |
        git fetch --all --prune --unshallow 2>$null || git fetch --all --prune
        $releaseBranch = 'origin/release'
        $exists = git branch -r --list $releaseBranch
        if (-not $exists) {
          Write-Host "âŒ Required branch 'release' not found on remote."; exit 1
        }
        $tagRef = "${{ github.ref_name }}"
        $tagCommit = git rev-list -n 1 $tagRef
        if (-not $tagCommit) { Write-Host "âŒ Unable to resolve tag commit"; exit 1 }
        git merge-base --is-ancestor $tagCommit $releaseBranch; if ($LASTEXITCODE -ne 0) {
          Write-Host "âŒ Tag $tagRef (commit $tagCommit) is NOT based on release branch. Abort."; exit 1
        }
        Write-Host "âœ… Tag $tagRef commit $tagCommit is contained in release branch."

    - name: ğŸ”’ Validate version.json consistency
      shell: pwsh
      run: |
        if (-Not (Test-Path version.json)) { Write-Host 'version.json missing'; exit 1 }
        $json = Get-Content version.json -Raw | ConvertFrom-Json
        if (-not $json.version) { Write-Host 'version.json missing version field'; exit 1 }
        $locked = $json.version
        $tagVersion = "${{ steps.version.outputs.version }}"  # includes leading v
        $tagNumber = $tagVersion -replace '^v',''
        if ($locked -ne $tagNumber) { Write-Host "âŒ Mismatch: version.json=$locked tag/version=$tagNumber"; exit 1 }
        Write-Host "âœ… version.json matches tag/version: $locked"
        if ($locked -notmatch '^[0-9]{4}\.[1-9]\d?\.[1-9]\d?\.[0-2]\d[0-5]\d$') { Write-Host "âŒ Locked version format invalid: $locked"; exit 1 }
        Write-Host "âœ… Locked version format valid."

  build-and-test:
    name: ğŸ§ª Build & Test
    runs-on: ubuntu-latest
    needs: prepare-release
    
    steps:
    - name: ï¿½ Setup Complete Environment
      uses: ./.github/actions/setup-environment
      with:
        fetch-depth: 0
        dotnet-version: ${{ env.DOTNET_VERSION }}
        enable-nuget-cache: true
        cache-key-suffix: '-release'
        
    - name: ğŸ”’ Validate locked version
      shell: pwsh
      run: |
        if (-not (Test-Path version.json)) { Write-Host 'version.json missing'; exit 1 }
        ./build.ps1 CheckVersionLocked
        
    - name: ï¿½ Full Build and Test
      uses: ./.github/actions/build-and-test
      with:
        configuration: 'Release'
        enable-coverage: true
      env:
        VERSION: ${{ needs.prepare-release.outputs.version-number }}
        RELEASE_VERSION: ${{ needs.prepare-release.outputs.version }}

    - name: ğŸ“Š Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: release-test-results
        path: artifacts/test-results/
        retention-days: 30
        
    - name: ğŸ“ˆ Upload coverage
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: release-coverage
        path: artifacts/coverage/
        retention-days: 30

  build-packages:
    name: ğŸ“¦ Build & Package
    needs: [prepare-release, build-and-test]
    strategy:
      fail-fast: true
      matrix:
        os: [windows-latest, macos-latest, ubuntu-latest]
        arch: [x64, arm64]
    runs-on: ${{ matrix.os }}
    steps:
      - name: ğŸ› ï¸ Setup Environment  
        uses: ./.github/actions/setup-environment
        
      - name: ğŸ”§ Setup WiX (Windows only)
        if: startsWith(matrix.os, 'windows')
        shell: pwsh
        run: |
          try { $wixVersion = & wix --version 2>$null; Write-Host "WiX: $wixVersion" } catch { dotnet tool install --global wix }
      - name: ğŸ“¦ Publish & Package
        uses: ./.github/actions/publish-package
        with:
          rid: ${{ matrix.os == 'windows-latest' && 'win' || matrix.os == 'macos-latest' && 'osx' || 'linux' }}-${{ matrix.arch }}
          configuration: 'Release'
        env:
          VERSION: ${{ needs.prepare-release.outputs.version-number }}
          RELEASE_VERSION: ${{ needs.prepare-release.outputs.version }}
          
      - name: ğŸ” Windows Authenticode Sign (MSI)
        if: startsWith(matrix.os, 'windows')
        shell: pwsh
        run: |
          if (-not $env:CODE_SIGN_WINDOWS_PFX_BASE64 -or -not $env:CODE_SIGN_WINDOWS_PFX_PASSWORD) { Write-Host "Skipping signing (missing CODE_SIGN_WINDOWS_* env)"; exit 0 }
          $rid = "win-${{ matrix.arch }}"
          $dir = "artifacts/packages/by-rid/$rid"
          if (-not (Test-Path $dir)) { Write-Host "No directory $dir"; exit 1 }
          $pfxPath = "$env:RUNNER_TEMP/code-signing.pfx"
          Write-Host "Decoding PFX..."
          try { [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:CODE_SIGN_WINDOWS_PFX_BASE64)) } catch { Write-Host "PFX decode failed"; exit 1 }
          $msis = Get-ChildItem $dir -Filter *.msi -File
          if (-not $msis) { Write-Host "No MSI files to sign"; exit 0 }
          foreach ($msi in $msis) {
            Write-Host "Signing $($msi.Name)"
            & signtool sign /f $pfxPath /p $env:CODE_SIGN_WINDOWS_PFX_PASSWORD /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 $msi.FullName
            if ($LASTEXITCODE -ne 0) { Write-Host "Sign failed"; exit 1 }
            & signtool verify /pa /all $msi.FullName | Out-Null
            if ($LASTEXITCODE -ne 0) { Write-Host "Verification failed"; exit 1 }
          }
          Write-Host "âœ… Windows MSI signing completed"
          Remove-Item $pfxPath -Force
      - name: ğŸ” macOS Codesign (PKG & DMG)
        if: startsWith(matrix.os, 'macos')
        shell: bash
        run: |
          set -e
          SIGN_IDENTITY="$MACOS_SIGN_IDENTITY"
          if [ -z "$SIGN_IDENTITY" ]; then echo "Skipping codesign (MACOS_SIGN_IDENTITY not set)"; exit 0; fi
          RID="osx-${{ matrix.arch }}"
          DIR="artifacts/packages/by-rid/$RID"
          echo "Codesign assets in $DIR"
          for f in "$DIR"/*.pkg "$DIR"/*.dmg; do
            [ -f "$f" ] || continue
            echo "Signing $f"
            codesign --force --timestamp --options runtime -s "$SIGN_IDENTITY" "$f"
            codesign --verify --verbose=2 "$f"
          done
          echo "âœ… macOS codesign completed"
      - name: ğŸ“¨ macOS Notarize (PKG & DMG)
        if: startsWith(matrix.os, 'macos')
        shell: bash
        run: |
          set -e
          APPLE_ID="$MACOS_NOTARIZE_APPLE_ID"
          APP_PASSWORD="$MACOS_NOTARIZE_PASSWORD"
          TEAM_ID="$MACOS_NOTARIZE_TEAM_ID"
          if [ -z "$APPLE_ID" ] || [ -z "$APP_PASSWORD" ] || [ -z "$TEAM_ID" ]; then echo "Skipping notarization (MACOS_NOTARIZE_* env not set)"; exit 0; fi
          RID="osx-${{ matrix.arch }}"
          DIR="artifacts/packages/by-rid/$RID"
          
          # Notarize all PKG and DMG files
          NOTARIZED_COUNT=0
          for f in "$DIR"/*.pkg "$DIR"/*.dmg; do
            [ -f "$f" ] || continue
            echo "Submitting $(basename "$f") for notarization..."
            xcrun notarytool submit "$f" --apple-id "$APPLE_ID" --password "$APP_PASSWORD" --team-id "$TEAM_ID" --wait
            echo "Stapling ticket to $(basename "$f")..."
            xcrun stapler staple "$f"
            xcrun stapler validate "$f"
            echo "âœ… $(basename "$f") notarized and stapled"
            NOTARIZED_COUNT=$((NOTARIZED_COUNT + 1))
          done
          
          if [ $NOTARIZED_COUNT -eq 0 ]; then
            echo "No PKG or DMG files found for notarization"
          else
            echo "âœ… Notarization completed for $NOTARIZED_COUNT file(s)"
          fi
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.os }}-${{ matrix.arch }}-release
          path: artifacts/packages/by-rid/${{ (contains(matrix.os,'windows') && 'win') || (contains(matrix.os,'macos') && 'osx') || (contains(matrix.os,'ubuntu') && 'linux') }}-${{ matrix.arch }}/
          retention-days: 90

  publish-release:
    name: ğŸš€ Publish Release
    runs-on: ubuntu-latest
    needs: [prepare-release, build-packages]
    
    steps:
    - name: ğŸ“¥ Checkout repository
      uses: actions/checkout@v4
      
    - name: ğŸ“¦ Download all release artifacts
      uses: actions/download-artifact@v4
      with:
        path: release-artifacts/
        pattern: "*-release"
        
    - name: ğŸ“‹ Prepare release assets
      shell: pwsh
      run: |
        $version = "${{ needs.prepare-release.outputs.version }}"
        $releaseDir = "final-release"
        New-Item -ItemType Directory -Path $releaseDir -Force
        Write-Host "ğŸ¯ Processing release artifacts for version: $version"
        Get-ChildItem "release-artifacts" -Directory | ForEach-Object {
          $platformDir = $_.FullName
          Write-Host "ğŸ“‚ Processing: $($_.Name)"
          Get-ChildItem "$platformDir" -File -Recurse | ForEach-Object {
            $file = $_
            Copy-Item $file.FullName "$releaseDir/$($file.Name)"
            Write-Host "  âœ… $($file.Name)"
          }
        }
        $expected = @(
          @{ Rid='win-x64';    Pattern='*-win-x64.msi';    Friendly='Windows x64 MSI' }
          @{ Rid='win-arm64';  Pattern='*-win-arm64.msi';  Friendly='Windows ARM64 MSI' }
          @{ Rid='osx-x64';    Pattern='*-osx-x64.pkg';    Friendly='macOS Intel PKG' }
          @{ Rid='osx-arm64';  Pattern='*-osx-arm64.pkg';  Friendly='macOS Apple Silicon PKG' }
          @{ Rid='linux-x64';  Pattern='*-linux-x64.deb'; Friendly='Linux x64 DEB' }
          @{ Rid='linux-arm64';Pattern='*-linux-arm64.deb';Friendly='Linux ARM64 DEB' }
        )
        $missing = @()
        foreach ($e in $expected) {
          if (-not (Get-ChildItem -Path $releaseDir -File -Filter $e.Pattern -ErrorAction SilentlyContinue)) {
            $missing += "$($e.Rid) -> expecting $($e.Friendly) pattern $($e.Pattern)"
          }
        }
        if ($missing.Count -gt 0) {
          Write-Host "âŒ Missing expected artifacts:" 
          $missing | ForEach-Object { Write-Host "  - $_" }
          exit 1
        } else {
          Write-Host "âœ… All expected RID installer artifacts present." 
        }
        $manifest = "SHASUMS-$version.txt"
        $manifestPath = Join-Path $releaseDir $manifest
        if (Test-Path $manifestPath) { Remove-Item $manifestPath -Force }
        Get-ChildItem $releaseDir -File | Sort-Object Name | ForEach-Object {
          $hash = Get-FileHash $_.FullName -Algorithm SHA256
          "$($hash.Hash)  $($_.Name)"
        } | Out-File -FilePath $manifestPath -Encoding ASCII
        Write-Host "ğŸ” (Optional) Verifying Authenticode signatures if signtool available..."
        if (Get-Command signtool -ErrorAction SilentlyContinue) {
          Get-ChildItem $releaseDir -Filter *.msi -File | ForEach-Object {
            & signtool verify /pa /all $_.FullName 2>$null | Out-Null
            if ($LASTEXITCODE -ne 0) { Write-Host "âš ï¸ Unsigned or verification failed: $($_.Name)" } else { Write-Host "âœ… Verified signature: $($_.Name)" }
          }
        } else { Write-Host "â„¹ï¸ signtool not present on this runner (expected on Windows only)" }
        Write-Host "ğŸ§¾ Wrote checksum manifest: $manifest"
        Get-Content $manifestPath | Select-Object -First 5 | ForEach-Object { Write-Host "  $_" }
        Write-Host "ğŸ“‹ Final release assets:"
        Get-ChildItem $releaseDir | Sort-Object Name | ForEach-Object { 
          Write-Host "  â€¢ $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)"
        }
    
    - name: ğŸ“ Generate categorized changelog & release body
      shell: bash
      env:
        VERSION: ${{ needs.prepare-release.outputs.version }}
      run: |
        set -euo pipefail
        TAG="$VERSION"
        PREV_TAG=$(git describe --tags --abbrev=0 ${TAG}^ 2>/dev/null || true)
        if [ -n "$PREV_TAG" ]; then RANGE="$PREV_TAG..$TAG"; else RANGE="$TAG"; fi
        echo "Generating changelog range: $RANGE"
        git log --format='%s' $RANGE > commits.txt || true
        awk 'BEGIN{IGNORECASE=1} \
          /^feat[:(]/ {feat=feat"\n- "substr($0,6)} \
          /^fix[:(]/ {fix=fix"\n- "substr($0,5)} \
          /^refactor[:(]/ {ref=ref"\n- "substr($0,10)} \
          /^perf[:(]/ {perf=perf"\n- "substr($0,6)} \
          /^docs[:(]/ {docs=docs"\n- "substr($0,6)} \
          /^build[:(]/ {builds=builds"\n- "substr($0,7)} \
          END{ if(feat)print "\n### âœ¨ Features"feat; if(fix)print "\n### ğŸ› Fixes"fix; if(ref)print "\n### â™»ï¸ Refactors"ref; if(perf)print "\n### ğŸš€ Performance"perf; if(docs)print "\n### ğŸ“ Docs"docs; if(builds)print "\n### ğŸ—ï¸ Build System"builds; }' commits.txt > categorized.md
        if [ ! -s categorized.md ]; then echo -e "\n### Changes\n- Internal adjustments" > categorized.md; fi
        {
          printf '%s\n' "## ğŸ‰ AGI.Captor $TAG" "" "### ğŸ“¦ Installation Packages" "" "**Windows:**" "- AGI.Captor-*-win-x64.msi" "- AGI.Captor-*-win-arm64.msi" "" "**macOS:**" "- AGI.Captor-*-osx-x64.pkg" "- AGI.Captor-*-osx-arm64.pkg" "" "**Linux:**" "- AGI.Captor-*-linux-x64.deb" "- AGI.Captor-*-linux-arm64.deb" "" "### ğŸ”„ Auto-Update" "This release includes automatic update functionality. The application will:" "- Check for updates in the background (every 24 hours by default)" "- Download and install updates automatically (configurable)" "- Support cross-platform update distribution" "" "### ğŸ” Integrity & Verification" "SHA-256 manifest: SHASUMS-$TAG.txt" "" "Linux/macOS verify all:" '```bash' "shasum -a 256 -c SHASUMS-$TAG.txt" '```' "" "Single file example:" '```bash' "grep AGI.Captor-*linux-x64.deb SHASUMS-$TAG.txt | shasum -a 256 -c -" '```' "" "PowerShell single file:" '```powershell' "$f = Get-Item .\\AGI.Captor-*win-x64.msi" "$expected = (Select-String -Path .\\SHASUMS-$TAG.txt -Pattern $f.Name).Line.Split(' ',[System.StringSplitOptions]::RemoveEmptyEntries)[0]" "$actual = (Get-FileHash $f.FullName -Algorithm SHA256).Hash" "if ($expected -ieq $actual) { Write-Host 'Hash OK' } else { Write-Host 'Mismatch!' ; exit 1 }" '```' "" "### ğŸ§¾ Changelog" "_Range: ${PREV_TAG:-Initial} â†’ $TAG_" ;
          cat categorized.md;
        } > custom-release-body.md
        head -n 60 custom-release-body.md
    
    - name: ğŸš€ Update GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        files: final-release/*
        tag_name: ${{ needs.prepare-release.outputs.version }}
        name: AGI.Captor ${{ needs.prepare-release.outputs.version }}
        prerelease: ${{ needs.prepare-release.outputs.is-prerelease }}
        generate_release_notes: false
        body_path: custom-release-body.md
        token: ${{ secrets.GH_PAT }}

  cleanup:
    name: ğŸ§¹ Cleanup
    runs-on: ubuntu-latest
    needs: [publish-release]
    if: always()
    
    steps:
    - name: ğŸ—‘ï¸ Delete intermediate artifacts
      uses: geekyeggo/delete-artifact@v5
      with:
        name: |
          windows-x64-release
          windows-arm64-release
          macos-x64-release
          macos-arm64-release
          linux-x64-release
          linux-arm64-release
        failOnError: false