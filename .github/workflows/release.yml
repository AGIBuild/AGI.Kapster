name: Release Build & Publish

# Release build and publish workflow
on:
  push:
    tags: [ 'v*' ]  # Trigger on version tags
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.0.0)'
        required: true
      prerelease:
        description: 'Is this a pre-release?'
        type: boolean
        default: false

permissions:
  contents: write
  id-token: write
concurrency:
  group: release-${{ github.ref || github.event.inputs.tag }}
  cancel-in-progress: false

env:
  DOTNET_VERSION: '9.0.x'
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  # Optional code signing / notarization placeholders
  CODE_SIGN_WINDOWS_PFX_BASE64: ''
  CODE_SIGN_WINDOWS_PFX_PASSWORD: ''
  MACOS_SIGN_IDENTITY: ''
  MACOS_NOTARIZE_APPLE_ID: ''
  MACOS_NOTARIZE_PASSWORD: ''
  MACOS_NOTARIZE_TEAM_ID: ''

jobs:
  prepare-release:
    name: ğŸ“‹ Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      version-number: ${{ steps.version.outputs.version-number }}
      is-prerelease: ${{ steps.version.outputs.is-prerelease }}
      
    steps:
    - name: ğŸ“¥ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: ğŸ”§ Setup Complete Environment
      uses: ./.github/actions/setup-environment
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        enable-nuget-cache: true
        
    - name: ğŸ“Š Determine version
      id: version
      shell: pwsh
      run: |
        Write-Host "Event Name: ${{ github.event_name }}"
        Write-Host "Ref Type: ${{ github.ref_type }}"
        Write-Host "Ref Name: ${{ github.ref_name }}"
        
        if ("${{ github.event_name }}" -eq "workflow_dispatch") {
          $version = "${{ github.event.inputs.tag }}"
          $isPrerelease = "${{ github.event.inputs.prerelease }}"
          Write-Host "Using workflow_dispatch inputs: $version"
        } elseif ("${{ github.ref_type }}" -eq "tag") {
          $version = "${{ github.ref_name }}"
          $isPrerelease = if ($version -match "-(alpha|beta|rc|preview)") { "true" } else { "false" }
          Write-Host "Using tag version: $version"
        } else {
          Write-Error "Unexpected trigger condition"
          exit 1
        }
        
        # Ensure version format
        if ($version -and -not $version.StartsWith("v")) {
          $version = "v$version"
        }
        
        # Export version without 'v' prefix for build scripts
        $versionNumber = $version -replace "^v", ""
        
        echo "version=$version" >> $env:GITHUB_OUTPUT
        echo "version-number=$versionNumber" >> $env:GITHUB_OUTPUT
        echo "is-prerelease=$isPrerelease" >> $env:GITHUB_OUTPUT
        
        Write-Host "ğŸ·ï¸ Release Version: $version"
        Write-Host "ğŸ”¢ Version Number: $versionNumber"
        Write-Host "ğŸ”„ Is Prerelease: $isPrerelease"

    - name: ğŸ” Enforce tag originates from release branch
      if: ${{ github.ref_type == 'tag' }}
      uses: actions/checkout@v4
      with:
        ref: release
        fetch-depth: 0

    - name: ğŸ”’ Validate release consistency
      shell: pwsh
      run: |
        # Validate version.json exists and is properly formatted
        if (-Not (Test-Path version.json)) { Write-Host 'âŒ version.json missing'; exit 1 }
        $json = Get-Content version.json -Raw | ConvertFrom-Json
        if (-not $json.version) { Write-Host 'âŒ version.json missing version field'; exit 1 }
        
        # Validate version format (four segments, last segment up to 5 digits)
        $locked = $json.version
        if ($locked -notmatch '^[0-9]{4}\.[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,5}$') { 
          Write-Host "âŒ Locked version format invalid: $locked"; exit 1 
        }
        
        # Validate tag-version consistency
        $tagVersion = "${{ steps.version.outputs.version }}"
        $tagNumber = $tagVersion -replace '^v',''
        if ($locked -ne $tagNumber) { 
          Write-Host "âŒ Mismatch: version.json=$locked tag/version=$tagNumber"; exit 1 
        }
        
        Write-Host "âœ… Release validation passed: version=$locked, tag=$tagVersion"

  build-and-test:
    name: ğŸ§ª Build & Test
    needs: prepare-release
    uses: ./.github/workflows/_reusable-build.yml
    with:
      configuration: 'Release'
      enable-coverage: true
      upload-artifacts: true
      artifact-retention-days: 30
    secrets: inherit

  build-packages:
    name: ğŸ“¦ Build & Package
    needs: [prepare-release, build-and-test]
    strategy:
      fail-fast: true
      matrix:
        include:
          - os: windows-latest
            arch: x64
            rid: win-x64
          - os: windows-latest
            arch: arm64
            rid: win-arm64
          - os: macos-latest
            arch: x64
            rid: osx-x64
          - os: macos-latest
            arch: arm64
            rid: osx-arm64
          - os: ubuntu-latest
            arch: x64
            rid: linux-x64
    runs-on: ${{ matrix.os }}
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          
      - name: ğŸ› ï¸ Setup Environment  
        uses: ./.github/actions/setup-environment
        
      - name: ğŸ”§ Setup WiX (Windows only)
        if: startsWith(matrix.os, 'windows')
        shell: pwsh
        run: |
          # Check if WiX is already available
          try { 
            $wixVersion = & wix --version 2>$null
            Write-Host "âœ… WiX already installed: $wixVersion"
          } catch {
            Write-Host "ğŸ“¦ Installing WiX toolset..."
            dotnet tool install --global wix --version 4.0.0
            # Add to PATH
            $wixPath = "$env:USERPROFILE\.dotnet\tools"
            if (Test-Path $wixPath) {
              $env:PATH = "$wixPath;$env:PATH"
              Write-Host "Added WiX to PATH: $wixPath"
            }
            # Verify installation
            try {
              $wixVersion = & wix --version 2>$null
              Write-Host "âœ… WiX installed successfully: $wixVersion"
            } catch {
              Write-Host "âš ï¸ WiX installation verification failed"
            }
          }
          
      - name: ğŸ“¦ Publish & Package
        uses: ./.github/actions/publish-package
        with:
          runtime-id: ${{ matrix.rid }}
          configuration: 'Release'
        env:
          VERSION: ${{ needs.prepare-release.outputs.version-number }}
          RELEASE_VERSION: ${{ needs.prepare-release.outputs.version }}
          
      - name: ğŸ” Windows Authenticode Sign (MSI)
        if: startsWith(matrix.os, 'windows')
        shell: pwsh
        run: |
          if (-not $env:CODE_SIGN_WINDOWS_PFX_BASE64 -or -not $env:CODE_SIGN_WINDOWS_PFX_PASSWORD) { Write-Host "Skipping signing (missing CODE_SIGN_WINDOWS_* env)"; exit 0 }
          $rid = "${{ matrix.rid }}"
          $dir = "artifacts/packages"
          if (-not (Test-Path $dir)) { Write-Host "No directory $dir"; exit 1 }
          $pfxPath = "$env:RUNNER_TEMP/code-signing.pfx"
          Write-Host "Decoding PFX..."
          try { [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:CODE_SIGN_WINDOWS_PFX_BASE64)) } catch { Write-Host "PFX decode failed"; exit 1 }
          $msis = Get-ChildItem $dir -Filter *.msi -File
          if (-not $msis) { Write-Host "No MSI files to sign"; exit 0 }
          foreach ($msi in $msis) {
            Write-Host "Signing $($msi.Name)"
            & signtool sign /f $pfxPath /p $env:CODE_SIGN_WINDOWS_PFX_PASSWORD /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 $msi.FullName
            if ($LASTEXITCODE -ne 0) { Write-Host "Sign fail"; exit 1 }
            & signtool verify /pa /all $msi.FullName | Out-Null
            if ($LASTEXITCODE -ne 0) { Write-Host "Verification failed"; exit 1 }
          }
          Write-Host "âœ… Windows MSI signing completed"
          Remove-Item $pfxPath -Force
          
      - name: ğŸ” macOS Codesign (PKG & DMG)
        if: startsWith(matrix.os, 'macos')
        shell: bash
        run: |
          set -e
          SIGN_IDENTITY="$MACOS_SIGN_IDENTITY"
          if [ -z "$SIGN_IDENTITY" ]; then echo "Skipping codesign (MACOS_SIGN_IDENTITY not set)"; exit 0; fi
          RID="${{ matrix.rid }}"
          DIR="artifacts/packages"
          echo "Codesign assets in $DIR"
          for f in "$DIR"/*.pkg "$DIR"/*.dmg; do
            [ -f "$f" ] || continue
            echo "Signing $f"
            codesign --force --timestamp --options runtime -s "$SIGN_IDENTITY" "$f"
            codesign --verify --verbose=2 "$f"
          done
          echo "âœ… macOS codesign completed"
          
      - name: ğŸ“¨ macOS Notarize (PKG & DMG)
        if: startsWith(matrix.os, 'macos')
        shell: bash
        run: |
          set -e
          APPLE_ID="$MACOS_NOTARIZE_APPLE_ID"
          APP_PASSWORD="$MACOS_NOTARIZE_PASSWORD"
          TEAM_ID="$MACOS_NOTARIZE_TEAM_ID"
          if [ -z "$APPLE_ID" ] || [ -z "$APP_PASSWORD" ] || [ -z "$TEAM_ID" ]; then echo "Skipping notarization (MACOS_NOTARIZE_* env not set)"; exit 0; fi
          RID="${{ matrix.rid }}"
          DIR="artifacts/packages"
          
          # Notarize all PKG and DMG files
          NOTARIZED_COUNT=0
          for f in "$DIR"/*.pkg "$DIR"/*.dmg; do
            [ -f "$f" ] || continue
            echo "Submitting $(basename "$f") for notarization..."
            xcrun notarytool submit "$f" --apple-id "$APPLE_ID" --password "$APP_PASSWORD" --team-id "$TEAM_ID" --wait
            echo "Stapling ticket to $(basename "$f")..."
            xcrun stapler staple "$f"
            xcrun stapler validate "$f"
            echo "âœ… $(basename "$f") notarized and stapled"
            NOTARIZED_COUNT=$((NOTARIZED_COUNT + 1))
          done
          
          if [ $NOTARIZED_COUNT -eq 0 ]; then
            echo "No PKG or DMG files found for notarization"
          else
            echo "âœ… Notarization completed for $NOTARIZED_COUNT file(s)"
          fi
          
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.os }}-${{ matrix.rid }}-release
          path: artifacts/packages/
          retention-days: 90

  publish-release:
    name: ğŸš€ Publish Release
    runs-on: ubuntu-latest
    needs: [prepare-release, build-packages]
    
    steps:
    - name: ğŸ“¥ Checkout repository
      uses: actions/checkout@v4
      
    - name: ğŸ“¦ Download all release artifacts
      uses: actions/download-artifact@v4
      with:
        path: release-artifacts/
        pattern: "*-release"
        
    - name: ğŸ“‹ Prepare release assets
      shell: pwsh
      run: |
        $version = "${{ needs.prepare-release.outputs.version }}"
        $releaseDir = "final-release"
        New-Item -ItemType Directory -Path $releaseDir -Force
        Write-Host "ğŸ¯ Processing release artifacts for version: $version"
        Get-ChildItem "release-artifacts" -Directory | ForEach-Object {
          $platformDir = $_.FullName
          Write-Host "ğŸ“‚ Processing: $($_.Name)"
          Get-ChildItem "$platformDir" -File -Recurse | ForEach-Object {
            $file = $_
            Copy-Item $file.FullName "$releaseDir/$($file.Name)"
            Write-Host "  âœ… $($file.Name)"
          }
        }
        $expected = @(
          @{ Rid='win-x64';    Pattern='*-win-x64-portable.zip';    Friendly='Windows x64 Portable ZIP' }
          @{ Rid='win-arm64';  Pattern='*-win-arm64-portable.zip';  Friendly='Windows ARM64 Portable ZIP' }
          @{ Rid='osx-x64';    Pattern='*-osx-x64.pkg';             Friendly='macOS Intel PKG' }
          @{ Rid='osx-arm64';  Pattern='*-osx-arm64.pkg';           Friendly='macOS Apple Silicon PKG' }
          @{ Rid='linux-x64';  Pattern='*-linux-x64-portable.zip'; Friendly='Linux x64 Portable ZIP' }
        )
        $missing = @()
        foreach ($e in $expected) {
          if (-not (Get-ChildItem -Path $releaseDir -File -Filter $e.Pattern -ErrorAction SilentlyContinue)) {
            $missing += "$($e.Rid) -> expecting $($e.Friendly) pattern $($e.Pattern)"
          }
        }
        if ($missing.Count -gt 0) {
          Write-Host "âŒ Missing expected artifacts:" 
          $missing | ForEach-Object { Write-Host "  - $_" }
          exit 1
        } else {
          Write-Host "âœ… All expected RID installer artifacts present." 
        }
        $manifest = "SHASUMS-$version.txt"
        $manifestPath = Join-Path $releaseDir $manifest
        if (Test-Path $manifestPath) { Remove-Item $manifestPath -Force }
        Get-ChildItem $releaseDir -File | Sort-Object Name | ForEach-Object {
          $hash = Get-FileHash $_.FullName -Algorithm SHA256
          "$($hash.Hash)  $($_.Name)"
        } | Out-File -FilePath $manifestPath -Encoding ASCII
        Write-Host "ğŸ” (Optional) Verifying Authenticode signatures if signtool available..."
        if (Get-Command signtool -ErrorAction SilentlyContinue) {
          Get-ChildItem $releaseDir -Filter *.msi -File | ForEach-Object {
            & signtool verify /pa /all $_.FullName 2>$null | Out-Null
            if ($LASTEXITCODE -ne 0) { Write-Host "âš ï¸ Unsigned or verification failed: $($_.Name)" } else { Write-Host "âœ… Verified signature: $($_.Name)" }
          }
        } else { Write-Host "â„¹ï¸ signtool not present on this runner (expected on Windows only)" }
        Write-Host "ğŸ§¾ Wrote checksum manifest: $manifest"
        Get-Content $manifestPath | Select-Object -First 5 | ForEach-Object { Write-Host "  $_" }
        Write-Host "ğŸ“‹ Final release assets:"
        Get-ChildItem $releaseDir | Sort-Object Name | ForEach-Object { 
          Write-Host "  â€¢ $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)"
        }
    
    - name: ğŸ“ Generate changelog
      id: changelog
      uses: ./.github/actions/generate-changelog
      with:
        version: ${{ needs.prepare-release.outputs.version }}
        output-file: changelog.md
        
    - name: ğŸ“ Generate release body
      shell: bash
      env:
        VERSION: ${{ needs.prepare-release.outputs.version }}
      run: |
        set -euo pipefail
        TAG="$VERSION"
        
        # Create release body with package info and changelog
        {
          printf '%s\n' "## ğŸ‰ AGI.Kapster $TAG" "" "### ğŸ“¦ Installer Packages" "" "**Windows:**" "- AGI.Kapster-*-win-x64-portable.zip (Portable)" "- AGI.Kapster-*-win-arm64-portable.zip (Portable)" "" "**macOS:**" "- AGI.Kapster-*-osx-x64.pkg (Intel Mac)" "- AGI.Kapster-*-osx-arm64.pkg (Apple Silicon)" "" "**Linux:**" "- AGI.Kapster-*-linux-x64-portable.zip (Portable)" "" "### ğŸ“‹ Additional Linux Packages" "- agi-kapster_*_amd64.deb (Debian/Ubuntu)" "- agi-kapster-*-1.x86_64.rpm (Red Hat/CentOS/Fedora)" "" "### ğŸ”„ Auto-Update" "This release includes automatic update functionality. The application will:" "- Check for updates in the background (every 24 hours by default)" "- Download and install updates automatically (configurable)" "- Support cross-platform update distribution" "" "### ğŸ” Integrity & Verification" "SHA-256 manifest: SHASUMS-$TAG.txt" "" "Linux/macOS verify all:" '```bash' "shasum -a 256 -c SHASUMS-$TAG.txt" '```' "" "Single file example:" '```bash' "grep AGI.Kapster-*linux-x64-portable.zip SHASUMS-$TAG.txt | shasum -a 256 -c -" '```' "" "PowerShell single file:" '```powershell' "\$f = Get-Item .\\AGI.Kapster-*win-x64-portable.zip" "\$expected = (Select-String -Path .\\SHASUMS-$TAG.txt -Pattern \$f.Name).Line.Split(' ',[System.StringSplitOptions]::RemoveEmptyEntries)[0]" "\$actual = (Get-FileHash \$f.FullName -Algorithm SHA256).Hash" "if (\$expected -ieq \$actual) { Write-Host 'Hash OK' } else { Write-Host 'Mismatch!' ; exit 1 }" '```' "" "### ğŸ§¾ Changelog" "";
          cat changelog.md;
        } > custom-release-body.md
        
        echo "ğŸ“‹ Generated release body:"
        head -n 20 custom-release-body.md
    
    - name: ğŸš€ Update GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        files: final-release/*
        tag_name: ${{ needs.prepare-release.outputs.version }}
        name: AGI.Kapster ${{ needs.prepare-release.outputs.version }}
        prerelease: ${{ needs.prepare-release.outputs.is-prerelease }}
        generate_release_notes: true  # Use GitHub official generation
        body_path: custom-release-body.md
        token: ${{ secrets.GH_PAT }}

  cleanup:
    name: ğŸ§¹ Cleanup
    runs-on: ubuntu-latest
    needs: [publish-release]
    if: always()
    
    steps:
    - name: ğŸ—‘ï¸ Delete intermediate artifacts
      uses: geekyeggo/delete-artifact@v5
      with:
        name: |
          windows-latest-win-x64-release
          windows-latest-win-arm64-release
          macos-latest-osx-x64-release
          macos-latest-osx-arm64-release
          ubuntu-latest-linux-x64-release
        failOnError: false
