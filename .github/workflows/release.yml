name: Release Build & Publish

# Release build and publish workflow
on:
  push:
    tags: [ 'v*' ]  # Trigger on version tags
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.0.0)'
        required: true
      prerelease:
        description: 'Is this a pre-release?'
        type: boolean
        default: false

permissions:
  contents: write
  id-token: write
concurrency:
  group: release-${{ github.ref || github.event.inputs.tag }}
  cancel-in-progress: false

env:
  DOTNET_VERSION: '9.0.x'
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  # Optional code signing / notarization placeholders
  CODE_SIGN_WINDOWS_PFX_BASE64: ''
  CODE_SIGN_WINDOWS_PFX_PASSWORD: ''
  MACOS_SIGN_IDENTITY: ''
  MACOS_NOTARIZE_APPLE_ID: ''
  MACOS_NOTARIZE_PASSWORD: ''
  MACOS_NOTARIZE_TEAM_ID: ''

jobs:
  prepare-release:
    name: üìã Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      version-number: ${{ steps.version.outputs.version-number }}
      is-prerelease: ${{ steps.version.outputs.is-prerelease }}
      
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: üîß Setup Complete Environment
      uses: ./.github/actions/setup-environment
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        enable-nuget-cache: true
        
    - name: üìä Determine version
      id: version
      shell: pwsh
      run: |
        Write-Host "Event Name: ${{ github.event_name }}"
        Write-Host "Ref Type: ${{ github.ref_type }}"
        Write-Host "Ref Name: ${{ github.ref_name }}"
        
        if ("${{ github.event_name }}" -eq "workflow_dispatch") {
          $version = "${{ github.event.inputs.tag }}"
          $isPrerelease = "${{ github.event.inputs.prerelease }}"
          Write-Host "Using workflow_dispatch inputs: $version"
        } elseif ("${{ github.ref_type }}" -eq "tag") {
          $version = "${{ github.ref_name }}"
          $isPrerelease = if ($version -match "-(alpha|beta|rc|preview)") { "true" } else { "false" }
          Write-Host "Using tag version: $version"
        } else {
          Write-Error "Unexpected trigger condition"
          exit 1
        }
        
        # Ensure version format
        if ($version -and -not $version.StartsWith("v")) {
          $version = "v$version"
        }
        
        # Export version without 'v' prefix for build scripts
        $versionNumber = $version -replace "^v", ""
        
        echo "version=$version" >> $env:GITHUB_OUTPUT
        echo "version-number=$versionNumber" >> $env:GITHUB_OUTPUT
        echo "is-prerelease=$isPrerelease" >> $env:GITHUB_OUTPUT
        
        Write-Host "üè∑Ô∏è Release Version: $version"
        Write-Host "üî¢ Version Number: $versionNumber"
        Write-Host "üîÑ Is Prerelease: $isPrerelease"

    - name: üîê Enforce tag originates from release branch
      if: ${{ github.ref_type == 'tag' }}
      uses: actions/checkout@v4
      with:
        ref: main
        fetch-depth: 0

    - name: üîí Validate release consistency
      shell: pwsh
      run: |
        # Validate version.json exists and is properly formatted
        if (-Not (Test-Path version.json)) { Write-Host '‚ùå version.json missing'; exit 1 }
        $json = Get-Content version.json -Raw | ConvertFrom-Json
        if (-not $json.version) { Write-Host '‚ùå version.json missing version field'; exit 1 }
        
        # Validate version format (four segments, last segment up to 5 digits)
        $locked = $json.version
        if ($locked -notmatch '^[0-9]{4}\.[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,5}$') { 
          Write-Host "‚ùå Locked version format invalid: $locked"; exit 1 
        }
        
        # Validate tag-version consistency
        $tagVersion = "${{ steps.version.outputs.version }}"
        $tagNumber = $tagVersion -replace '^v',''
        if ($locked -ne $tagNumber) { 
          Write-Host "‚ùå Mismatch: version.json=$locked tag/version=$tagNumber"; exit 1 
        }
        
        Write-Host "‚úÖ Release validation passed: version=$locked, tag=$tagVersion"

  build-and-test:
    name: üß™ Build & Test
    needs: prepare-release
    uses: ./.github/workflows/_reusable-build.yml
    with:
      configuration: 'Release'
      enable-coverage: true
      upload-artifacts: true
      artifact-retention-days: 30
    secrets: inherit

  build-packages:
    name: üì¶ Build & Package
    needs: [prepare-release, build-and-test]
    strategy:
      fail-fast: true
      matrix:
        include:
          - os: windows-latest
            arch: x64
            rid: win-x64
          - os: windows-latest
            arch: arm64
            rid: win-arm64
          - os: macos-latest
            arch: x64
            rid: osx-x64
          - os: macos-latest
            arch: arm64
            rid: osx-arm64
          - os: ubuntu-latest
            arch: x64
            rid: linux-x64
    runs-on: ${{ matrix.os }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          
      - name: üõ†Ô∏è Setup Environment  
        uses: ./.github/actions/setup-environment
        
      - name: üîß Setup WiX (Windows only)
        if: startsWith(matrix.os, 'windows')
        shell: pwsh
        run: |
          # Check if WiX is already available
          try { 
            $wixVersion = & wix --version 2>$null
            Write-Host "‚úÖ WiX already installed: $wixVersion"
          } catch {
            Write-Host "üì¶ Installing WiX toolset..."
            dotnet tool install --global wix --version 6.0.2
            # Add to PATH
            $wixPath = "$env:USERPROFILE\.dotnet\tools"
            if (Test-Path $wixPath) {
              $env:PATH = "$wixPath;$env:PATH"
              Write-Host "Added WiX to PATH: $wixPath"
            }
            # Verify installation
            try {
              $wixVersion = & wix --version 2>$null
              Write-Host "‚úÖ WiX installed successfully: $wixVersion"
            } catch {
              Write-Host "‚ö†Ô∏è WiX installation verification failed"
            }
          }
          
      - name: üì¶ Publish & Package
        uses: ./.github/actions/publish-package
        with:
          runtime-id: ${{ matrix.rid }}
          configuration: 'Release'
        env:
          VERSION: ${{ needs.prepare-release.outputs.version-number }}
          RELEASE_VERSION: ${{ needs.prepare-release.outputs.version }}
          
      - name: üîê Windows Authenticode Sign (MSI)
        if: startsWith(matrix.os, 'windows')
        shell: pwsh
        run: |
          if (-not $env:CODE_SIGN_WINDOWS_PFX_BASE64 -or -not $env:CODE_SIGN_WINDOWS_PFX_PASSWORD) { Write-Host "Skipping signing (missing CODE_SIGN_WINDOWS_* env)"; exit 0 }
          $rid = "${{ matrix.rid }}"
          $dir = "artifacts/packages"
          if (-not (Test-Path $dir)) { Write-Host "No directory $dir"; exit 1 }
          $pfxPath = "$env:RUNNER_TEMP/code-signing.pfx"
          Write-Host "Decoding PFX..."
          try { [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:CODE_SIGN_WINDOWS_PFX_BASE64)) } catch { Write-Host "PFX decode failed"; exit 1 }
          $msis = Get-ChildItem $dir -Filter *.msi -File
          if (-not $msis) { Write-Host "No MSI files to sign"; exit 0 }
          foreach ($msi in $msis) {
            Write-Host "Signing $($msi.Name)"
            & signtool sign /f $pfxPath /p $env:CODE_SIGN_WINDOWS_PFX_PASSWORD /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 $msi.FullName
            if ($LASTEXITCODE -ne 0) { Write-Host "Sign fail"; exit 1 }
            & signtool verify /pa /all $msi.FullName | Out-Null
            if ($LASTEXITCODE -ne 0) { Write-Host "Verification failed"; exit 1 }
          }
          Write-Host "‚úÖ Windows MSI signing completed"
          Remove-Item $pfxPath -Force
          
      - name: üîê macOS Codesign (PKG & DMG)
        if: startsWith(matrix.os, 'macos')
        shell: bash
        run: |
          set -e
          SIGN_IDENTITY="$MACOS_SIGN_IDENTITY"
          if [ -z "$SIGN_IDENTITY" ]; then echo "Skipping codesign (MACOS_SIGN_IDENTITY not set)"; exit 0; fi
          RID="${{ matrix.rid }}"
          DIR="artifacts/packages"
          echo "Codesign assets in $DIR"
          for f in "$DIR"/*.pkg "$DIR"/*.dmg; do
            [ -f "$f" ] || continue
            echo "Signing $f"
            codesign --force --timestamp --options runtime -s "$SIGN_IDENTITY" "$f"
            codesign --verify --verbose=2 "$f"
          done
          echo "‚úÖ macOS codesign completed"
          
      - name: üì® macOS Notarize (PKG & DMG)
        if: startsWith(matrix.os, 'macos')
        shell: bash
        run: |
          set -e
          APPLE_ID="$MACOS_NOTARIZE_APPLE_ID"
          APP_PASSWORD="$MACOS_NOTARIZE_PASSWORD"
          TEAM_ID="$MACOS_NOTARIZE_TEAM_ID"
          if [ -z "$APPLE_ID" ] || [ -z "$APP_PASSWORD" ] || [ -z "$TEAM_ID" ]; then echo "Skipping notarization (MACOS_NOTARIZE_* env not set)"; exit 0; fi
          RID="${{ matrix.rid }}"
          DIR="artifacts/packages"
          
          # Notarize all PKG and DMG files
          NOTARIZED_COUNT=0
          for f in "$DIR"/*.pkg "$DIR"/*.dmg; do
            [ -f "$f" ] || continue
            echo "Submitting $(basename "$f") for notarization..."
            xcrun notarytool submit "$f" --apple-id "$APPLE_ID" --password "$APP_PASSWORD" --team-id "$TEAM_ID" --wait
            echo "Stapling ticket to $(basename "$f")..."
            xcrun stapler staple "$f"
            xcrun stapler validate "$f"
            echo "‚úÖ $(basename "$f") notarized and stapled"
            NOTARIZED_COUNT=$((NOTARIZED_COUNT + 1))
          done
          
          if [ $NOTARIZED_COUNT -eq 0 ]; then
            echo "No PKG or DMG files found for notarization"
          else
            echo "‚úÖ Notarization completed for $NOTARIZED_COUNT file(s)"
          fi
          
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.os }}-${{ matrix.rid }}-release
          path: artifacts/packages/
          retention-days: 90

  publish-release:
    name: üöÄ Publish Release
    runs-on: ubuntu-latest
    needs: [prepare-release, build-packages]
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4
      
    - name: üì¶ Download all release artifacts
      uses: actions/download-artifact@v4
      with:
        path: release-artifacts/
        pattern: "*-release"
        
    - name: üìã Prepare release assets
      shell: pwsh
      run: |
        $version = "${{ needs.prepare-release.outputs.version }}"
        $releaseDir = "final-release"
        New-Item -ItemType Directory -Path $releaseDir -Force
        Write-Host "üéØ Processing release artifacts for version: $version"
        Get-ChildItem "release-artifacts" -Directory | ForEach-Object {
          $platformDir = $_.FullName
          Write-Host "üìÇ Processing: $($_.Name)"
          # Copy all files except build/debug artifacts like .wixpdb
          Get-ChildItem "$platformDir" -File -Recurse | Where-Object { $_.Extension -ne '.wixpdb' } | ForEach-Object {
              $file = $_
              Copy-Item $file.FullName "$releaseDir/$($file.Name)"
              Write-Host "  ‚úÖ $($file.Name)"
            }
        }
        $expected = @(
          @{ Rid='win-x64';    Pattern='*-win-x64.msi';    Friendly='Windows x64 MSI' }
          @{ Rid='win-arm64';  Pattern='*-win-arm64.msi';  Friendly='Windows ARM64 MSI' }
          @{ Rid='osx-x64';    Pattern='*-osx-x64.pkg';             Friendly='macOS Intel PKG' }
          @{ Rid='osx-arm64';  Pattern='*-osx-arm64.pkg';           Friendly='macOS Apple Silicon PKG' }
          @{ Rid='linux-x64';  Pattern='*-linux-x64-portable.zip'; Friendly='Linux x64 Portable ZIP' }
        )
        $missing = @()
        foreach ($e in $expected) {
          if (-not (Get-ChildItem -Path $releaseDir -File -Filter $e.Pattern -ErrorAction SilentlyContinue)) {
            $missing += "$($e.Rid) -> expecting $($e.Friendly) pattern $($e.Pattern)"
          }
        }
        if ($missing.Count -gt 0) {
          Write-Host "‚ùå Missing expected artifacts:" 
          $missing | ForEach-Object { Write-Host "  - $_" }
          exit 1
        } else {
          Write-Host "‚úÖ All expected RID installer artifacts present." 
        }
        $manifest = "SHASUMS-$version.txt"
        $manifestPath = Join-Path $releaseDir $manifest
        if (Test-Path $manifestPath) { Remove-Item $manifestPath -Force }
        Get-ChildItem $releaseDir -File | Where-Object { $_.Extension -ne '.wixpdb' } | Sort-Object Name | ForEach-Object {
          $hash = Get-FileHash $_.FullName -Algorithm SHA256
          "$($hash.Hash)  $($_.Name)"
        } | Out-File -FilePath $manifestPath -Encoding ASCII
        Write-Host "üîé (Optional) Verifying Authenticode signatures if signtool available..."
        if (Get-Command signtool -ErrorAction SilentlyContinue) {
          Get-ChildItem $releaseDir -Filter *.msi -File | ForEach-Object {
            & signtool verify /pa /all $_.FullName 2>$null | Out-Null
            if ($LASTEXITCODE -ne 0) { Write-Host "‚ö†Ô∏è Unsigned or verification failed: $($_.Name)" } else { Write-Host "‚úÖ Verified signature: $($_.Name)" }
          }
        } else { Write-Host "‚ÑπÔ∏è signtool not present on this runner (expected on Windows only)" }
        Write-Host "üßæ Wrote checksum manifest: $manifest"
        Get-Content $manifestPath | Select-Object -First 5 | ForEach-Object { Write-Host "  $_" }
        Write-Host "üìã Final release assets:"
        Get-ChildItem $releaseDir -File | Where-Object { $_.Extension -ne '.wixpdb' } | Sort-Object Name | ForEach-Object { 
          Write-Host "  ‚Ä¢ $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)"
        }
    
    - name: üìù Generate release body
      shell: bash
      env:
        VERSION: ${{ needs.prepare-release.outputs.version }}
      run: |
        set -euo pipefail
        TAG="$VERSION"
        
        # Create release body with package info (GitHub will auto-generate changelog)
        {
          printf '%s\n' "## üéâ AGI.Kapster $TAG" "" "### üì¶ Installer Packages" "" "**Windows:**" "- AGI.Kapster-*-win-x64.msi (MSI, x64)" "- AGI.Kapster-*-win-arm64.msi (MSI, arm64)" "" "**macOS:**" "- AGI.Kapster-*-osx-x64.pkg (Intel Mac)" "- AGI.Kapster-*-osx-arm64.pkg (Apple Silicon)" "" "**Linux:**" "- AGI.Kapster-*-linux-x64-portable.zip (Portable)" "" "### üìã Additional Linux Packages" "- agi-kapster_*_amd64.deb (Debian/Ubuntu)" "- agi-kapster-*-1.x86_64.rpm (Red Hat/CentOS/Fedora)" "" "### üîÑ Auto-Update" "This release includes automatic update functionality. The application will:" "- Check for updates in the background (every 24 hours by default)" "- Download and install updates automatically (configurable)" "- Support cross-platform update distribution" "" "### üîê Integrity & Verification" "SHA-256 manifest: SHASUMS-$TAG.txt" "" "Linux/macOS verify all:" '```bash' "shasum -a 256 -c SHASUMS-$TAG.txt" '```' "" "PowerShell sample for verifying MSI (Windows):" '```powershell' "\$f = Get-Item .\\AGI.Kapster-*win-x64.msi" "\$expected = (Select-String -Path .\\SHASUMS-$TAG.txt -Pattern \$f.Name).Line.Split(' ',[System.StringSplitOptions]::RemoveEmptyEntries)[0]" "\$actual = (Get-FileHash \$f.FullName -Algorithm SHA256).Hash" "if (\$expected -ieq \$actual) { Write-Host 'Hash OK' } else { Write-Host 'Mismatch!' ; exit 1 }" '```' "";
        } > custom-release-body.md
        
        echo "üìã Generated release body:"
        head -n 20 custom-release-body.md
    
    - name: üöÄ Update GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        files: final-release/*
        tag_name: ${{ needs.prepare-release.outputs.version }}
        name: AGI.Kapster ${{ needs.prepare-release.outputs.version }}
        prerelease: ${{ needs.prepare-release.outputs.is-prerelease }}
        generate_release_notes: true  # Use GitHub's automatic changelog generation
        token: ${{ secrets.GH_PAT }}

  cleanup:
    name: üßπ Cleanup
    runs-on: ubuntu-latest
    needs: [publish-release]
    if: always()
    
    steps:
    - name: üóëÔ∏è Delete intermediate artifacts
      uses: geekyeggo/delete-artifact@v5
      with:
        name: |
          windows-latest-win-x64-release
          windows-latest-win-arm64-release
          macos-latest-osx-x64-release
          macos-latest-osx-arm64-release
          ubuntu-latest-linux-x64-release
        failOnError: false
